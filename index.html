<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Muon Visualizer</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    #controls {
      position: absolute; top: 10px; left: 10px; z-index: 10;
      background: rgba(255,255,255,0.8); padding: 10px; border-radius: 5px;
    }
    input { display: block; margin: 5px 0; }
  </style>
</head>
<body>
  <div id="controls">
    <label>Загрузить Detectors.txt:
      <input type="file" id="detectorsFile">
    </label>
    <label>Загрузить Tracks_DistrOutput.dat:
      <input type="file" id="tracksFile">
    </label>
  </div>
  <canvas id="scene"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    let scene, camera, renderer, controls;

    initScene();

    function initScene() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 10000);
      camera.position.set(0, 200, 500);

      renderer = new THREE.WebGLRenderer({canvas: document.getElementById('scene')});
      renderer.setSize(window.innerWidth, window.innerHeight);

      controls = new THREE.OrbitControls(camera, renderer.domElement);

      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(100, 200, 100);
      scene.add(light);
      scene.add(new THREE.AmbientLight(0x404040));

      const axesHelper = new THREE.AxesHelper(200);
      scene.add(axesHelper);

      animate();
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    // ==== Загрузка и отрисовка детекторов ====
    document.getElementById('detectorsFile').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        const lines = reader.result.trim().split('\n');
        let added = 0;
        lines.forEach(line => {
          const parts = line.trim().split(/[,\s]+/);
          if (parts.length >= 4) {
            const x = parseFloat(parts[1]);
            const y = parseFloat(parts[2]);
            const z = parseFloat(parts[3]);
            if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
              addDetector(x, y, z);
              added++;
            }
          }
        });
        console.log(`Детекторов добавлено: ${added}`);
      };
      reader.readAsText(file);
    });

    function addDetector(x, y, z) {
      const geometry = new THREE.SphereGeometry(5, 16, 16);
      const material = new THREE.MeshStandardMaterial({color: 0xff0000});
      const sphere = new THREE.Mesh(geometry, material);
      sphere.position.set(x, z, y); // Y — вертикаль
      scene.add(sphere);
    }

    // ==== Загрузка и отрисовка направлений мюонов ====
    document.getElementById('tracksFile').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        const lines = reader.result.trim().split('\n');
        let added = 0;
        lines.forEach(line => {
          const parts = line.trim().split(/[,\s]+/); // пробелы или запятые
          if (parts.length >= 3) {
            const theta = parseFloat(parts[0]);
            const phi = parseFloat(parts[1]);
            const count = parseFloat(parts[2]);
            if (!isNaN(theta) && !isNaN(phi) && !isNaN(count)) {
              addMuonDirection(theta, phi, count);
              added++;
            }
          }
        });
        console.log(`Векторов мюонов добавлено: ${added}`);
      };
      reader.readAsText(file);
    });

    function addMuonDirection(thetaDeg, phiDeg, count) {
      const length = 50 + count * 0.01; // масштаб длины по числу треков
      const theta = thetaDeg * Math.PI / 180;
      const phi = phiDeg * Math.PI / 180;
      const dir = new THREE.Vector3(
        Math.sin(theta) * Math.cos(phi),
        Math.cos(theta),
        Math.sin(theta) * Math.sin(phi)
      );
      const points = [
        new THREE.Vector3(0,0,0),
        dir.clone().multiplyScalar(length)
      ];
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({color: 0x00ff00});
      const line = new THREE.Line(geometry, material);
      scene.add(line);
    }
  </script>
</body>
</html>

